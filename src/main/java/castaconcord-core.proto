package castaconcord;

option java_package = "org.castaconcord.core";
option java_outer_classname = "ProtocolBuffer";

message HeaderMessage {
	optional SenderInformationMsg senderInfo=1;
	optional uint32 requestNumber=2; 
	optional bytes applicationId=3;
	optional bytes signature=4;
	//Notice there is no payload in the protobuf message. It is simply appended as a multipart message
	optional uint32 applicationSpecificBlockLength=5;
	optional uint32 applicationSpecificStreamLength=6;
};

message SenderInformationMsg {
  optional string userAgent=1;
  optional string externalIP=2;
  optional uint32 externalPort=3;
  optional bytes nodePublicKey=4;
  repeated bytes applicationsSupported=5;
};

message NetworkMessage {
	enum NetworkOperation {
		CLOSE_CONNECTION=0;
		PING=1;
		PONG=2;
	}
	optional NetworkOperation operation=1;
};

//Gossip application
message GossipMessage {
  optional GossipRequestMorePeers requestMorePeers=1;
  optional GossipReplyMorePeers reply=2;
};

message GossipRequestMorePeers {
  repeated bytes applicationsRequested=1; //If omited, return a bunch of peers
};

message GossipReplyMorePeers {
	message PeerEndpoint {
		message IPEndpoint {
			optional string ipaddress=1;
			optional uint32 port=2;
		};
		message TOREndpoint {
			optional string TORAddress=1;
		};
		optional bytes identity=1;
		optional IPEndpoint ipEndpoint=2;
	}
	repeated PeerEndpoint peers=1;
};

message GenericResponse {
  optional uint32 errorCode=1;
  optional string errorMessage=2;
};

/////////////////////////////HashToPublicKey application

message HashToPublicKeyMessage {
  optional GenericResponse genericResponse=1;
  optional H2PKProposedTransactions proposedTx=2;
  
  //Typically, only the client would use these fields
  optional HashToPublicKeyTransaction localTransaction=3;
  optional bytes membershipQuery=4;
  repeated bytes membershipResponse=5;

  optional H2PKDBSyncQuery dbSyncQuery=6;
  optional H2PKDBSyncResponse dbSyncResponse=7;
};

message HashToPublicKeyTransaction {
  enum OPERATION {
    APPEND=0;
    REMOVE=1;
  }
  optional OPERATION operation=1;
  optional bytes address=2;
  optional bytes publicKey=3;
  optional bytes signature=4;
  optional uint32 expiration=5;
};

message H2PKProposedTransactions {
  optional uint32 dbVersionNumber=1;
  optional bytes proposedBy=2;
  repeated HashToPublicKeyTransaction proposedTransactions=3;
};

message H2PKDBSyncQuery {
  optional uint32 beginDbVersionNumber=1;
};

message H2PKDBSyncResponse {
  optional uint32 lastDbVersionNumber=1;
  optional bytes lastDbHashValue=2;

  optional uint32 syncDbVersionNumber=3;
  repeated H2PKDBSyncUnit syncUnits=4;
};

message H2PKDBSyncUnit {
	optional bytes address=1;
	repeated bytes publicKeysRegistered=2;
};


//////////////P2PBlob /////////////////
message P2PBlobRange {
  optional uint32 begin=1;
  optional uint32 end=2;
};

message P2PBlobRequest {
  optional bytes requestedHash=1;
  //Maybe a maximumBlobHintLength? Malicious blob with huge hint could be a problem?
  
  /*Maximum number of bytes the response may return. If the blobBytes exceed this, 
    no blobBytes are returned, but the remaining header bytes are returned. If set to 0,
    no blobBytes will be returned.
  */
  optional uint64 maximumBlobLength=2;
  optional bool requestHashList=3;
  optional bool requestBlobLength=4;
  repeated P2PBlobRange requestedRanges=5;
};

message P2PBlobResponse {
  optional GenericResponse genericResponse=1;
  optional P2PBlobHashListMsg hashList=2;
  optional uint64 blobLength=3;
  repeated P2PBlobBlockMsg blobBytes=4;
};

message P2PBlobBlockMsg {
	optional uint32 blockIndex=1;
	optional bytes blobBytes=2;
};

message P2PBlobHashListMsg {
  repeated bytes hashBytes=1;
};

/////////////// Settlement ////////////////

message SettlementMessage {
  optional bool requestSettlementMethod=1;
  optional bool requestTermsOfService=2; //Goes for any service

  optional SettlementMethod settlementMethod=21;
};

message SettlementMethod {
  optional bytes bitcoinAddress=1;
  //Probably more stuff here for micro payment channels
  //optional bytes bitcoinEscrowAddress=2;
  
  optional bytes rippleAddress=11;
  repeated bytes acceptedRippleCurrencies=12;
};

/*** This stuff should go on a per app basis ************/
message SettlementTermOfServiceByteStorage {
  optional bytes pricePerBytePerPeriod=1;
  optional uint32 storagePeriodInSeconds=2; //Per Hour, Per day,Per month?

  optional uint64 minimumNumberOfBytes=3; //To create usage tiers
  optional uint32 recoveryDelayInSeconds=5; //How much time may elapse before we return the data 
};

message SettlementTermOfServiceByteTransfer {
  optional bytes priceIncomingPerByte=1;
  optional bytes priceOutgoingPerByte=2;
  optional uint32 maximumIncomingBytesPerSecond=3;
  optional uint32 maximumOutgoingBytesPerSecond=4;
};


